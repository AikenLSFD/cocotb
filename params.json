{"name":"Cocotb","tagline":"Coroutine Co-simulation Test Bench ","body":"\r\n**cocotb** is a coroutine based cosimulation library for writing VHDL and Verilog testbenches in Python.\r\n\r\nRationale\r\n=========\r\nVHDL and Verilog are both unsuitable for writing complex testbenches. eRM, SystemVerilog and the various SV based methodologies have emerged to address this deficiency. These verification methodologies are large and cumbersome, requiring specialist knowledge, significant time investment and expensive toolchains to achieve satisfactory verification. The overhead of setting up testbenches is onerous so often designers write small throwaway testbenches at a block level and defer the majority of verification to a large system level testbench. Cocotb intends to bridge this gap in order to make block-level testing useful, reusable, fast, accessible to a much wider skill-set. The net effect is that bugs will be discovered earlier in the design cycle which equates to significant time and cost saving.\r\n\r\n\r\nOverview\r\n========\r\n\r\n\r\nA typical cocotb testbench requires no additional RTL code. The Design Under Test (DUT) is instantiated as the toplevel in the simulator without any wrapper code. Cocotb drives stimulus onto the inputs to the DUT (or further down the hierarchy) and monitors the outputs directly from Python.\r\n\r\nCocotb comprises 3 layers:\r\n\r\n### GPI (Generic Procedural Interface)\r\n\r\nThis layer abstracts the simulator language interface to provide a common set of functionality. Supports VHDL via VHPI and Verilog/SystemVerilog via VPI. Modelsim FLI may be supported in the future.\r\n\r\n### simulatormodule\r\n\r\nA CPython extension which utilises GPI to expose the simulator to Python.\r\n\r\n### cocotb Python package\r\n\r\nPython infrastructure including coroutine scheduler, base classes etc. The cocotb package provides a mechanism to traverse the hierarchy, query signal values, force signals to particular values and control simulator execution.\r\n\r\nExample\r\n=======\r\n\r\nA simplistic example of generating a clock with 10ns period:\r\n```python\r\n@cocotb.coroutine\r\ndef clock(signal):\r\n    while True:\r\n        signal <= 1\r\n        yield Timer(5)\r\n        signal <= 0\r\n        yield Timer(5)\r\n```\r\n\r\nThe python \"yield\" keyword is used to suspend the coroutine and return control back to the simulator until a condition is met. In this case, the condition is a simple timer that fires after 5ns of simulation time.\r\n\r\nThis may seem pretty pointless, in fact a Verilog process to perform the same operation requires fewer lines of code. Let's examine a more useful example:\r\n\r\n```python\r\n@cocotb.coroutine\r\ndef pcap_replay(bus, filename):\r\n    prevtime = 0\r\n    for timestamp, packet in dpkt.pcap.Reader(open(filename, 'r')):\r\n        yield Timer((timestamp - prevtime) * 1000)\r\n        yield bus.send(packet)\r\n```\r\n\r\nHere we utilise a thirdparty python library called dpkt to iterate over packets in a PCAP packet capture. This becomes trivially easy in Python when compared to a VHDL/Verilog/SystemVerilog implementation. The argument \"bus\" is an instance of a Driver class which provides a send method to serialise the packet transaction over multiple cycles on the bus. Although the majority of the complexity is hidden in this (reusable) Driver class the actual implementation is once again straightforward:\r\n\r\n```python\r\ndef send(self, packet):\r\n\r\n    words = len(packet) / (len(self.data) / 8)\r\n\r\n    yield RisingEdge(self.clk)            # Synchronise to bus clock\r\n    self.sop <= 1                         # First word is start-of-packet\r\n    self.valid <= 1\r\n\r\n    for index, word in enumerate(packet):\r\n        self.data <= word\r\n        yield rising_edge(self.clk)        \r\n        self.sop <= 0\r\n        if index == words - 1:\r\n            self.eop <= 1\r\n            self.len <= len(word)\r\n\r\n    yield rising_edge(self.clk)\r\n    self.eop <= 0\r\n    self.valid <= 0\r\n```\r\n\r\nAdvantages\r\n==========\r\n* Low overhead to creating testbenches to facilitate block-level verification\r\n* Favourable learning curve compared to eRM/OVM/UVM\r\n* Leverage existing Python and C libraries easily\r\n* Multi-language (Verilog/VHDL) and cross multi-simulator compatible\r\n* Supports directed and randomised testing\r\n\r\n\r\nDisadvantages\r\n=============\r\n* Simulation is slower than native language testbench\r\n* Non-standard\r\n\r\n\r\nSimilar projects\r\n================\r\n\r\nSeveral examples exist of projects providing a VPI interface into a language other than C and (most notably http://pyhvl.sourceforge.net/ and http://snk.tuxfamily.org/lib/ruby-vpi/). MyHDL (http://www.myhdl.org/) seeks to displace VHDL and Verilog with a Python framework that can generate synthesiable RTL.\r\n","google":"UA-41678571-1","note":"Don't delete this file! It's used internally to help with page regeneration."}